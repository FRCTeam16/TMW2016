// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "OI.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "SmartDashboard/SmartDashboard.h"
#include "Commands/AutonomousCommand.h"
#include "Commands/SetWheelOffsets.h"


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

OI::OI() {
    // Process operator interface input here.
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    gamepad.reset(new Joystick(2));
    
    driverRight.reset(new Joystick(1));
    
    driverLeft.reset(new Joystick(0));
    

    // SmartDashboard Buttons
    SmartDashboard::PutData("SetWheelOffsets", new SetWheelOffsets());
    SmartDashboard::PutData("Autonomous Command", new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    pi = 3.14159;
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

std::shared_ptr<Joystick> OI::getDriverLeft() {
   return driverLeft;
}

std::shared_ptr<Joystick> OI::getDriverRight() {
   return driverRight;
}

std::shared_ptr<Joystick> OI::getGamepad() {
   return gamepad;
}


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

double OI::getScaledJoystickRadians() {
	double steerAngle = pi/2;
	steerAngle = driverRight->GetDirectionRadians();
	if(steerAngle > pi)
		steerAngle = pi;
	if(steerAngle < -pi)
		steerAngle = -pi;

	if(steerAngle < -pi/2)
		steerAngle = -pi/2 - steerAngle;
	else if(steerAngle < pi/2)
		steerAngle = pi/2 + steerAngle;
	else
		steerAngle = 3*pi/2 - steerAngle;
//	scalingFactor = driverJoystick->GetTwist()/2+1.5;

	return scaledRadians(steerAngle);
}
double OI::getJoystickMagnitude() {
	if(driverRight->GetMagnitude() < .1)
		return 0;
	else
		if (driverRight->GetY()<0)
			return -driverRight->GetMagnitude();
		else
			return driverRight->GetMagnitude();
}
double OI::getJoystickTwist() {
	if(fabs(driverLeft->GetX()) < .1)
			return 0;
	else
		return driverLeft->GetX()/2;
}
double OI::getJoystickX() {
	if (fabs(driverRight->GetX()) < 0)
		return 0;
	else
		return driverRight->GetX();
}
double OI::getJoystickY() {
	if (fabs(driverRight->GetY()) < 0)
		return 0;
	else
		return driverRight->GetY();
}
double OI::getLeftJoystickXRadians() {
	if(fabs(driverLeft->GetX())<.00)
		return pi/2;
	else
		return scaledRadians(pi/2 + driverLeft->GetX()*pi/2);
}
double OI::scaledRadians(double radians) {
	double scaledradians = pi/2;
	double scalingFactor = 1.8;
	if(radians <= pi/2)
		scaledradians = (-(pi/2)/pow(pow(-pi/2,2),scalingFactor/2))*pow(pow(radians-pi/2,2),scalingFactor/2) + pi/2;
	else //if(steerAngle <= pi)
		scaledradians = ((pi/2)/pow((pi/2),scalingFactor))*pow(radians-pi/2,scalingFactor) + pi/2;

	return scaledradians;
}

double OI::getScaledJoystick (double value, double scaling) {
	return pow(value,scaling);
}

